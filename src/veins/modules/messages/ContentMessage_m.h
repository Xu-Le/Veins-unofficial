//
// Generated file, do not edit! Created by nedtool 5.0 from veins/modules/messages/ContentMessage.msg.
//

#ifndef __CONTENTMESSAGE_M_H
#define __CONTENTMESSAGE_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0500
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include "veins/modules/messages/WaveShortMessage_m.h"
enum ContentMsgCC {
    CONTENT_REQUEST,
    CONTENT_RESPONSE,
    SCHEME_DISTRIBUTION,
    ACKNOWLEDGEMENT,
    CARRIER_SELECTION,
    LINK_BREAK_DIRECT,
    LINK_BREAK_DR,
    LINK_BREAK_RR,
    RELAY_DISCOVERY,
    DISCOVERY_RESPONSE
};

class SchemeTuple
{
public:
	SchemeTuple() : slot(-1), receiver(-1), downloader(-1), amount(-1) {}
    SchemeTuple(int s, int r, int d, int a) : slot(s), receiver(r), downloader(d), amount(a) {}
    SchemeTuple(const SchemeTuple& rhs) : slot(rhs.slot), receiver(rhs.receiver), downloader(rhs.downloader), amount(rhs.amount) {}

	SchemeTuple& operator=(const SchemeTuple& rhs)
	{
	    if (this == &rhs)
	    	return *this;
		slot = rhs.slot;
		receiver = rhs.receiver;
		downloader = rhs.downloader;
		amount = rhs.amount;
		return *this;
	}

    int slot;
    int receiver;
    int downloader;
    int amount;
};
typedef std::list<std::pair<Coord /* pos */, Coord /* speed */> > NeighborItems;
typedef std::map<long /* addr */, std::list<SchemeTuple> > SchemeItems;
// }}

/**
 * Class generated from <tt>veins/modules/messages/ContentMessage.msg:65</tt> by nedtool.
 * <pre>
 * packet ContentMessage extends WaveShortMessage
 * {
 *     // @brief express which kind of control signaling message
 *     // 0: content request;
 *     // 1: RSU's response to content request;
 *     // 2: distribute current RSU's slot decision to relays;
 *     // 3: selected to be carrier by the cooperative RSU;
 *     // 4: link break notify - the communication link between downloader and RSU will break soon;
 *     // 5: link break notify - the communication link between downloader and relay will break soon;
 *     // 6: link break notify - the communication link between relay and RSU will break soon;
 *     // 7: cooperative RSU's discover notification sends to the first entering relay;
 *     // 8: the first entering relay response to cooperative RSU's discover notification.
 *     int controlCode;
 *     int downloader;  // which downloader this content message aims to
 *     int contentSize; // content size of request large-volume file
 *     int receivedOffset; // data amount received offset
 *     int consumedOffset; // data amount consumed offset
 *     int consumingRate;  // data amount consuming rate measured in Bytes each second
 *     NeighborItems neighborInfo; // neighbors information of current downloader (controlCode: 4,5,6)
 *     SchemeItems scheme; // transmitssion scheme each vehicle should obey (controlCode: 2)
 * }
 * </pre>
 */
class ContentMessage : public ::WaveShortMessage
{
  protected:
    int controlCode;
    int downloader;
    int contentSize;
    int receivedOffset;
    int consumedOffset;
    int consumingRate;
    NeighborItems neighborInfo;
    SchemeItems scheme;

  private:
    void copy(const ContentMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ContentMessage&);

  public:
    ContentMessage(const char *name=nullptr, int kind=0);
    ContentMessage(const ContentMessage& other);
    virtual ~ContentMessage();
    ContentMessage& operator=(const ContentMessage& other);
    virtual ContentMessage *dup() const {return new ContentMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getControlCode() const;
    virtual void setControlCode(int controlCode);
    virtual int getDownloader() const;
    virtual void setDownloader(int downloader);
    virtual int getContentSize() const;
    virtual void setContentSize(int contentSize);
    virtual int getReceivedOffset() const;
    virtual void setReceivedOffset(int receivedOffset);
    virtual int getConsumedOffset() const;
    virtual void setConsumedOffset(int consumedOffset);
    virtual int getConsumingRate() const;
    virtual void setConsumingRate(int consumingRate);
    virtual NeighborItems& getNeighborInfo();
    virtual const NeighborItems& getNeighborInfo() const {return const_cast<ContentMessage*>(this)->getNeighborInfo();}
    virtual void setNeighborInfo(const NeighborItems& neighborInfo);
    virtual SchemeItems& getScheme();
    virtual const SchemeItems& getScheme() const {return const_cast<ContentMessage*>(this)->getScheme();}
    virtual void setScheme(const SchemeItems& scheme);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ContentMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ContentMessage& obj) {obj.parsimUnpack(b);}


#endif // ifndef __CONTENTMESSAGE_M_H

